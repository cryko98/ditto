import os
import json
import uuid
import threading
import time
from flask import Flask, request, jsonify, send_from_directory
from anthropic import Anthropic

# â”€â”€ Flask app â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Vercel expects an `app` object at module level in api/index.py
app = Flask(__name__)

# â”€â”€ In-memory session store â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
sessions = {}
sessions_lock = threading.Lock()

# â”€â”€ Anthropic client â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def get_client():
    api_key = os.environ.get("ANTHROPIC_API_KEY")
    if not api_key:
        return None
    return Anthropic(api_key=api_key)

# â”€â”€ Tool definitions for the agent â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TOOLS = [
    {
        "name": "create_file",
        "description": "Create or overwrite a file. Path must start with templates/, static/, or routes/.",
        "input_schema": {
            "type": "object",
            "properties": {
                "path": {
                    "type": "string",
                    "description": "File path, e.g. templates/index.html or static/style.css"
                },
                "content": {
                    "type": "string",
                    "description": "Full file content"
                }
            },
            "required": ["path", "content"]
        }
    },
    {
        "name": "read_file",
        "description": "Read an existing file's content.",
        "input_schema": {
            "type": "object",
            "properties": {
                "path": {"type": "string", "description": "File path to read"}
            },
            "required": ["path"]
        }
    },
    {
        "name": "list_files",
        "description": "List all created files so far.",
        "input_schema": {
            "type": "object",
            "properties": {}
        }
    },
    {
        "name": "task_completed",
        "description": "Call this when the app is fully built and all files are created.",
        "input_schema": {
            "type": "object",
            "properties": {
                "summary": {
                    "type": "string",
                    "description": "Brief summary of what was built"
                }
            },
            "required": ["summary"]
        }
    }
]

SYSTEM_PROMPT = """You are Ditto, a self-building web application agent.

Your job: build a complete, working single-page web application based on the user's description.

IMPORTANT â€” this runs in a browser preview (srcdoc iframe):
- Build a STATIC web app â€” pure HTML, CSS, JavaScript ONLY
- NO server-side code needed
- Everything runs client-side in the browser
- Use CDN libraries freely (Bootstrap, Chart.js, etc.)

REQUIRED:
1. templates/index.html â€” The main app (REQUIRED)
2. static/style.css â€” Custom styles (optional)
3. static/app.js â€” JS logic (optional, or inline in HTML)

RULES:
- Fully functional â€” no placeholders, no TODOs
- Use Bootstrap 5 CDN for layout
- All interactivity via JavaScript
- localStorage for data persistence if needed
- index.html must be self-contained and work immediately
- Start with create_file for templates/index.html
- When ALL files are created, call task_completed()

Build step by step. Start immediately."""


def add_log(session_id, message, level="info"):
    with sessions_lock:
        if session_id in sessions:
            sessions[session_id]["logs"].append({
                "message": message,
                "level": level,
                "ts": time.time()
            })


def run_agent(session_id, description):
    """Run the Ditto agent in a background thread."""
    files = {}

    def tool_create_file(path, content):
        allowed = ["templates/", "static/", "routes/"]
        if not any(path.startswith(p) for p in allowed):
            return f"Error: path must start with templates/, static/, or routes/"
        files[path] = content
        add_log(session_id, f"ğŸ“„ Created: {path} ({len(content)} chars)", "success")
        return f"File created: {path}"

    def tool_read_file(path):
        if path in files:
            return files[path]
        return f"Error: file '{path}' not found"

    def tool_list_files():
        if not files:
            return "No files created yet."
        return "\n".join(files.keys())

    messages = [
        {"role": "user", "content": f"Build this app: {description}"}
    ]

    add_log(session_id, f"ğŸš€ Agent started", "info")
    add_log(session_id, f"ğŸ“ Building: {description}", "info")

    client = get_client()
    if not client:
        add_log(session_id, "âŒ ANTHROPIC_API_KEY not set!", "error")
        with sessions_lock:
            if session_id in sessions:
                sessions[session_id]["status"] = "error"
        return

    max_iterations = 15
    iteration = 0

    try:
        while iteration < max_iterations:
            iteration += 1
            add_log(session_id, f"ğŸ”„ Thinking... (step {iteration})", "info")

            response = client.messages.create(
                model="claude-opus-4-6",
                max_tokens=4096,
                system=SYSTEM_PROMPT,
                tools=TOOLS,
                messages=messages
            )

            messages.append({"role": "assistant", "content": response.content})

            tool_calls_made = False
            tool_results = []
            completed = False

            for block in response.content:
                if block.type == "text" and block.text.strip():
                    snippet = block.text[:150].replace('\n', ' ')
                    add_log(session_id, f"ğŸ¤– {snippet}{'...' if len(block.text) > 150 else ''}", "agent")

                elif block.type == "tool_use":
                    tool_calls_made = True
                    fname = block.name
                    args = block.input

                    log_args = {k: v for k, v in args.items() if k != 'content'}
                    add_log(session_id, f"ğŸ”§ {fname}({', '.join(f'{k}={repr(v)[:40]}' for k,v in log_args.items())})", "tool")

                    if fname == "create_file":
                        result = tool_create_file(args["path"], args["content"])
                    elif fname == "read_file":
                        result = tool_read_file(args["path"])
                    elif fname == "list_files":
                        result = tool_list_files()
                        add_log(session_id, f"   â†’ {result}", "info")
                    elif fname == "task_completed":
                        summary = args.get("summary", "App built!")
                        add_log(session_id, f"ğŸ‰ Done: {summary}", "success")
                        completed = True
                        result = "Task marked as completed."
                    else:
                        result = f"Unknown tool: {fname}"

                    tool_results.append({
                        "type": "tool_result",
                        "tool_use_id": block.id,
                        "content": str(result)
                    })

            if tool_results:
                messages.append({"role": "user", "content": tool_results})

            if completed:
                break

            if not tool_calls_made and response.stop_reason == "end_turn":
                add_log(session_id, "âœ… Agent finished", "success")
                break

        # Assemble final HTML
        index_html = files.get("templates/index.html", "")
        css = files.get("static/style.css", "")
        js = files.get("static/app.js", "")

        if not index_html:
            add_log(session_id, "âš ï¸ No index.html was created!", "warning")
            index_html = "<html><body><h1>Build failed â€” no index.html created</h1></body></html>"

        # Inject CSS
        if css:
            if "</head>" in index_html:
                index_html = index_html.replace("</head>", f"<style>\n{css}\n</style>\n</head>")
            else:
                index_html = f"<style>\n{css}\n</style>\n" + index_html

        # Inject JS
        if js:
            if "</body>" in index_html:
                index_html = index_html.replace("</body>", f"<script>\n{js}\n</script>\n</body>")
            else:
                index_html = index_html + f"\n<script>\n{js}\n</script>"

        with sessions_lock:
            if session_id in sessions:
                sessions[session_id]["status"] = "done"
                sessions[session_id]["result"] = {
                    "html": index_html,
                    "files": list(files.keys())
                }

        add_log(session_id, f"âœ… Build complete! Files: {', '.join(files.keys())}", "success")

    except Exception as e:
        import traceback
        err = traceback.format_exc()
        add_log(session_id, f"âŒ Error: {str(e)}", "error")
        print(err)
        with sessions_lock:
            if session_id in sessions:
                sessions[session_id]["status"] = "error"
                sessions[session_id]["error"] = str(e)


# â”€â”€ Routes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

@app.route("/")
def index():
    """Serve the main UI from public/index.html via Flask."""
    public_dir = os.path.join(os.path.dirname(__file__), "..", "public")
    return send_from_directory(os.path.abspath(public_dir), "index.html")


@app.route("/api/build", methods=["POST"])
def api_build():
    data = request.get_json() or {}
    description = data.get("description", "").strip()

    if not description:
        return jsonify({"error": "No description provided"}), 400

    if not os.environ.get("ANTHROPIC_API_KEY"):
        return jsonify({"error": "ANTHROPIC_API_KEY environment variable is not set"}), 500

    session_id = str(uuid.uuid4())

    with sessions_lock:
        # Keep max 20 sessions
        if len(sessions) >= 20:
            oldest = sorted(sessions.keys())[0]
            del sessions[oldest]

        sessions[session_id] = {
            "status": "building",
            "logs": [],
            "result": None
        }

    thread = threading.Thread(
        target=run_agent,
        args=(session_id, description),
        daemon=True
    )
    thread.start()

    return jsonify({"session_id": session_id})


@app.route("/api/poll/<session_id>")
def api_poll(session_id):
    """Polling endpoint â€” returns new logs since offset and current status."""
    try:
        offset = int(request.args.get("offset", 0))
    except (ValueError, TypeError):
        offset = 0

    with sessions_lock:
        session = sessions.get(session_id)

    if not session:
        return jsonify({"error": "Session not found"}), 404

    new_logs = session["logs"][offset:]
    status = session["status"]
    result = session.get("result") if status == "done" else None

    return jsonify({
        "logs": new_logs,
        "status": status,
        "offset": offset + len(new_logs),
        "result": result
    })


@app.route("/api/health")
def health():
    has_key = bool(os.environ.get("ANTHROPIC_API_KEY"))
    return jsonify({"status": "ok", "api_key_set": has_key})


# â”€â”€ Local dev entrypoint â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if __name__ == "__main__":
    port = int(os.environ.get("PORT", 5000))
    print(f"Starting Ditto on http://localhost:{port}")
    app.run(debug=True, host="0.0.0.0", port=port, threaded=True)
